<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 3.4.0"/><link as="script" rel="preload" href="/EI2030/webpack-runtime-704de7640f80019ab4e6.js"/><link as="script" rel="preload" href="/EI2030/framework-388411f792712f2fed40.js"/><link as="script" rel="preload" href="/EI2030/app-0a8333ced13b2efa4820.js"/><link as="script" rel="preload" href="/EI2030/component---src-pages-groups-working-group-page-working-group-name-working-group-page-file-name-js-d112a950ba3af77b59b4.js"/><link as="fetch" rel="preload" href="/EI2030/page-data/groups/psychology-and-ux/text-editor/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/EI2030/page-data/sq/d/2744905544.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/EI2030/page-data/app-data.json" crossorigin="anonymous"/></head><body><script>(function() { try {
  var mode = localStorage.getItem('theme-ui-color-mode');
  if (!mode) return
  document.documentElement.classList.add('theme-ui-' + mode);
  document.body.classList.add('theme-ui-' + mode);
} catch (e) {} })();</script><div id="___gatsby"><style data-emotion="css-global 167dzma">body{color:var(--theme-ui-colors-text);background-color:var(--theme-ui-colors-background);}</style><style data-emotion="css-global 0"></style><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div><a href="/EI2030/">EI2030 Home</a><h2><a href="/EI2030/groups/psychology-and-ux/">Working Group: <!-- -->Psychology and UX</a></h2><ul><li style="display:inline-block;margin-left:1em"><a href="/EI2030/groups/psychology-and-ux/template/">template</a></li><li style="display:inline-block;margin-left:1em"><a href="/EI2030/groups/psychology-and-ux/overview/">overview</a></li><li style="display:inline-block;margin-left:1em"><a href="/EI2030/groups/psychology-and-ux/general/">general</a></li><li style="display:inline-block;margin-left:1em"><a href="/EI2030/groups/psychology-and-ux/deep-os/">deep-os</a></li><li style="display:inline-block;margin-left:1em"><a href="/EI2030/groups/psychology-and-ux/einkux-highlvloverview/">einkux-highlvloverview</a></li><li style="display:inline-block;margin-left:1em"><a aria-current="page" class="" style="text-decoration:none" href="/EI2030/groups/psychology-and-ux/text-editor/">text-editor</a></li></ul><h1></h1><div><h1>UX case study - eink text editor</h1>
<h6>tags: <code>psych-ux</code> <code>ux</code> <code>case study</code> <code>productivity suite</code></h6>
<h2>5 theorized UI design principles for an e-ink text-editor:</h2>
<ol>
<li>
<p>Paginate screens, don't scroll (we already knew that)</p>
</li>
<li>
<p>Because refreshing takes longer than LCD, the user can't easily spot an instantaneous change of the screen contents, and is liable to forget the exact layout of the screen when it flickers and some part of it changes. Thus, if it's not extremely obvious what changed, we should have some lasting indication of what just changed after a screen refresh. For instance, a column next to line numbering with a "*" on the lines that just changed.</p>
</li>
<li>
<p>This is a more general principle, but newbies aren't familiar with the exact behaviour of the program, so anything that's surprising (which could basically be anything) should be conveyed for a sec or two after it happens. I'm pretty sure this is why animation exist on LCD-screen UIs (e.g. a screen minimizes without warning and even though you weren't looking at it, the motion draws your eye after half a second and the 1-second animation means you still have half a second of watching the animation to understand it's moved to the taskbar).</p>
</li>
<li>
<p>Refreshing = you're blind for a couple of seconds and can't navigate or check stuff = sucks and should be minimized as much as possible. As in, minimize the number of partial refreshes and also avoid full-refreshes when a partial refresh would do. A few ideas for how to counter this:</p>
<ul>
<li>
<p>a) if you're editing a line with text after the cursor, then instead of constantly reflowing the entire paragraph, perhaps either:</p>
<ul>
<li>i) overlay the edit until the user stops  typing and then reflow the entire thing just once</li>
<li>ii) put the typing into a separate blank spot on screen then put an arrow to indicate where the text will be placed (perhaps if we have a full line's worth of vertical empty space between lines,  we can just have the typing displayed between the lines below with a ^.), or</li>
</ul>
</li>
<li>
<p>b) if you're adding to a line and you need more space from the paragraph below you, perhaps a partial refresh could simply shrink the one paragraph below without needing to shrink any paragraphs <em>below the below</em>. Obviously, un-shrink the paragraph after a full reflow.</p>
</li>
<li>
<p>c) if you're deleting text, just use a strikethrough temporarily, perhaps? This might be an unnecessary delay that merely damages the immediacy of the action, especially if you've already highlighted the section. Worth testing idk.</p>
</li>
</ul>
</li>
<li>
<p>Following on from 3 and 4b, if a <em>lot</em> of stuff moved around on the screen, then it would be helpful to explain what went where. Especially if your reflow involves both unshrinking a paragraph and reflowing the text below it. Ideas for making a full-screen refresh/reflow clearer:</p>
<ul>
<li>a) Similar to the "asterisk column" idea from point 2, perhaps a line for each paragraph that moved going from where it was <em>before</em> the refresh to where it is <em>after</em>. Obviously we'd need to do a bunch of texting (with yet another effing text editor, because clearly the world needs more of those lol)</li>
<li>b) Perhaps make a full reflow a manual action bound to a button. This completely removes the chance of a "surprise refresh".</li>
<li>c) Instead of refreshing the whole screen at once, maybe refresh each 'step' individually so maybe it's clearer? As in, either:
<ul>
<li>i) refresh each e.g. 20% of the screen (split horizontal into bundles of lines)  one at a time, from top to bottom
<ul>
<li>^here see partial refresh of eink screens</li>
</ul>
</li>
<li>ii) do each logical reflow action separately - so, do a strikethrough then another strikethrough then unshrink a paragraph etc etc in the order the user right did it.</li>
</ul>
</li>
<li>d) Maybe show a "minimap" of what a whole-screen reflow would look like, before it refreshes? As in, have a permanent minimap that updates more-or-less immediately. Would work well with the "manual refresh"  and the 5a.</li>
</ul>
</li>
</ol></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/groups/psychology-and-ux/text-editor/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-2b4dc1da88fa4af9dd1a.js"],"app":["/app-0a8333ced13b2efa4820.js"],"component---src-pages-404-js":["/component---src-pages-404-js-fa3156fd98a1fb53118c.js"],"component---src-pages-groups-working-group-page-working-group-name-working-group-page-file-name-js":["/component---src-pages-groups-working-group-page-working-group-name-working-group-page-file-name-js-d112a950ba3af77b59b4.js"],"component---src-pages-index-js":["/component---src-pages-index-js-3a8753f3163a5bdc860f.js"]};/*]]>*/</script><script src="/EI2030/polyfill-2b4dc1da88fa4af9dd1a.js" nomodule=""></script><script src="/EI2030/component---src-pages-groups-working-group-page-working-group-name-working-group-page-file-name-js-d112a950ba3af77b59b4.js" async=""></script><script src="/EI2030/app-0a8333ced13b2efa4820.js" async=""></script><script src="/EI2030/framework-388411f792712f2fed40.js" async=""></script><script src="/EI2030/webpack-runtime-704de7640f80019ab4e6.js" async=""></script></body></html>